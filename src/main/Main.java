package main;

import java.io.File;
import java.io.FileReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import cc.mallet.fst.SimpleTagger;
import cc.mallet.pipe.Pipe;
import cc.mallet.pipe.SerialPipes;
import cc.mallet.pipe.iterator.LineGroupIterator;
import cc.mallet.pipe.tsf.LexiconMembership;
import cc.mallet.types.Alphabet;
import cc.mallet.types.AugmentableFeatureVector;
import cc.mallet.types.FeatureVector;
import cc.mallet.types.FeatureVectorSequence;
import cc.mallet.types.Instance;
import cc.mallet.types.InstanceList;
import cc.mallet.types.LabelAlphabet;
import cc.mallet.types.LabelSequence;
import cc.mallet.util.MalletLogger;

public class Main {

	private static final String TRAIN_FILE = "data/train.txt";
	private static final String TEST_FILE = "data/test.txt";
	private static Logger logger = 
			MalletLogger.getLogger(Main.class.getName());
	
	public static void main(String[] args) throws Exception {
		// TODO Auto-generated method stub
		
		GenTrainingData.genTrainTest();
		
//		Reader trainingFile = null, testFile = null;
//		InstanceList trainingData = null, testData = null;
//		Pipe p = new Sentence2FeatureVectorSequence();
////		List<Pipe> pipeList = new ArrayList<>();
////		p = new SerialPipes(pipeList);
//		
//		testFile = new FileReader(new File(TEST_FILE));
//		trainingData = new InstanceList(p);
//		trainingData.addThruPipe(new LineGroupIterator(testFile,
//													   Pattern.compile("^\\s*$"), true));
//		
//		logger.info("Number of features in training data: "+p.getDataAlphabet().size());
//		
//		for (Instance instance : trainingData) {
//			System.out.println(instance.getData());
//			System.out.println(instance.getTarget());
//			System.out.println("====================");
//		}
		
//		System.out.println("Done.");
	}

	
	public static class Sentence2FeatureVectorSequence extends Pipe {

		// gdruck
		// Previously, there was no serialVersionUID.  This is ID that would 
		// have been automatically generated by the compiler.  Therefore,
		// other changes should not break serialization.  
		private static final long serialVersionUID = -2059308802200728625L;

		/**
		 * Creates a new
		 * <code>SimpleTaggerSentence2FeatureVectorSequence</code> instance.
		 */
		public Sentence2FeatureVectorSequence () {
			super (new Alphabet(), new LabelAlphabet());
		}

		/**
		 * Parses a string representing a sequence of rows of tokens into an
		 * array of arrays of tokens.
		 *
		 * @param sentence a <code>String</code>
		 * @return the corresponding array of arrays of tokens.
		 */
		private String[][] parseSentence(String sentence) {
			String[] lines = sentence.split("\n");
			String[][] tokens = new String[lines.length][];
			for (int i = 0; i < lines.length; i++) {
				tokens[i] = lines[i].split(" ");
			}
			return tokens;
		}

		public Instance pipe (Instance carrier) {

			Object inputData = carrier.getData();
			Alphabet features = getDataAlphabet();
			LabelAlphabet labels;
			LabelSequence target = null;
			String [][] tokens;

			if (inputData instanceof String) {
				tokens = parseSentence((String)inputData);
			}
			else if (inputData instanceof String[][]) {
				tokens = (String[][])inputData;
			}
			else {
				throw new IllegalArgumentException("Not a String or String[][]; got " + inputData);
			}

			FeatureVector[] fvs = new FeatureVector[tokens.length];
			if (isTargetProcessing()) {
				labels = (LabelAlphabet)getTargetAlphabet();
				target = new LabelSequence (labels, tokens.length);
			}

			for (int l = 0; l < tokens.length; l++) {
				int nFeatures;
				if (isTargetProcessing()) {
					if (tokens[l].length < 1) {
						throw new IllegalStateException ("Missing label at line " + l + " instance "+carrier.getName ());
					}
					nFeatures = tokens[l].length - 1;
					target.add(tokens[l][nFeatures]);
				}
				else nFeatures = tokens[l].length;
				ArrayList<Integer> featureIndices = new ArrayList<Integer>();
				for (int f = 0; f < nFeatures; f++) {
					int featureIndex = features.lookupIndex(tokens[l][f]);
					// gdruck
					// If the data alphabet's growth is stopped, featureIndex
					// will be -1.  Ignore these features.
					if (featureIndex >= 0) {
						featureIndices.add(featureIndex);
					}
				}
				int[] featureIndicesArr = new int[featureIndices.size()];
				for (int index = 0; index < featureIndices.size(); index++) {
					featureIndicesArr[index] = featureIndices.get(index);
				}
				fvs[l] = new FeatureVector(features, featureIndicesArr);
			}
			carrier.setData(new FeatureVectorSequence(fvs));
			if (isTargetProcessing()) {
				carrier.setTarget(target);
			}
			else {
				carrier.setTarget(new LabelSequence(getTargetAlphabet()));
			}
			return carrier;
		}
	}
}
